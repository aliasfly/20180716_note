https://blog.csdn.net/u013165704/article/details/72828249
要实现IAP功能一般要设计两部分代码:
一是BootLoader程序，这部分程序存储在FLASH的某一位置，主要用来引导、升级App程序；
二是App程序，这个程序才是实现产品的功能程序。通过BootLoader来完成对App程序的更新升级;
这就是IAP功能。
STM32有三种启动方式，主要是通过管脚BOOT0和BOOT1的连接方式来控制的;
因为我们要让程序从主存储器启动，因而在硬件设计时要选择第一种方式把BOOT0接到GND，BOOT1任意，可以拉高也可以拉低。
0x08000000;64K ;BootLoader程序
0x08010000;128K;App程序
0x08030000;64K ;程序运行的标志位和其他
STM32的正常启动流程是：
a. STM32上电后会从 0x8000004 处取出复位中断向量的地址，并跳转执行复位中断服务程序，如标号1所示；
b. 复位中断复位程序执行完成之后就会跳转到我们的main函数如标号2所示；
c. main函数一般为死循环，当其收到某一中断请求之后STM32会强制把PC指针指向中断向量表，如标号3所示；
d. 查询中断向量表，根据中断源来跳转到相应的中断服务程序中执行响应的操作；如标号4、5所示；
e. 执行完中断服务程序之后会再回到main函数中，如标号6所示。
加入IAP后程序运行如下：
a. STM32复位之后还是从0x8000004处获取中断向量表的地址，并跳转执行复位中断服务程序，如标号1所示；
b. 执行完复位中断服务程序之后回调转到IAP的main函数中，如标号2所示；
c. IAP的过程就是通过某种选定的通信方式（如串口）来接收程序文件，并且存储在指定的FLASH空间里，随后会加载新的程序，而新程序的复位中断向量起始地址为0X08000004+N+M，取出新程序的复位中断向量的地址，并跳转执行新程序的复位中断服务程序，随后跳转至新程序的 main 函数，如标号3、4所示；
d. 此时在STM32的FLASH里面会有两个中断向量表，在新程序 main 函数执行的过程中，当中断来临时PC指针仍会回跳转至地址为0x8000004 中断向量表处，而并不是新程序的中断向量表，这是由STM32的硬件机制决定的，如标号5所示；
e. 查询中断向量表，根据中断源来跳转到新的中断服务程序中执行响应的操作，如标号6所示；
f. 执行完中断服务程序之后会再回到main函数中，如标号7、8所示。
note:
由上可知新的程序在FLASH中必须放在IAP程序之后的某个地址里，这里我的程序中设置的是0x08010000 即偏移量为0x10000，而且新程序
的中断向量表也要做相应的偏移，偏移量也为0x10000 （地址的设置可以通过编译软件来实现，下文会有介绍）。
bin文件的转换
升级程序时编译出的程序文件最好选用bin格式的文件，因为bin文件比hex文件要小的多从而占用的FLASH更小，这是比较主观的优点，使用IAR软件编译时可以通过对软件的设置来输出bin格式的可执行文件


